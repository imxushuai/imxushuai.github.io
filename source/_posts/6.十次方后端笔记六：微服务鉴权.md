---
title: 十次方后端笔记六：微服务鉴权
tags:
  - 十次方授权中心微服务
  - JWT
categories:
  - 十次方项目
abbrlink: 8347
date: 2002-01-02 00:00:06
---

<center><i>使用 JWT 完成微服务鉴权</i></center>

![](https://dev.tencent.com/u/imxushuai/p/pic/git/raw/master/tensquare.jpg)

<!-- more -->

# 用户微服务

用户微服务密码加密存入数据库。

## 密码加密

### 准备工作

1. 引入依赖

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-security</artifactId>
   </dependency>
   ```

2. 安全配置类

   ```java
   import org.springframework.context.annotation.Configuration;
   import org.springframework.security.config.annotation.web.builders.HttpSecurity;
   import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
   import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
   
   /**
    * 安全配置类
    */
   @Configuration
   @EnableWebSecurity
   public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http
                   .authorizeRequests()
                   .antMatchers("/**").permitAll()
                   .anyRequest().authenticated()
                   .and().csrf().disable();
       }
   }
   ```

3. 配置加密工具类

   ```java
   package com.tensquare.user.config;
   
   import org.springframework.context.annotation.Bean;
   import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
   import org.springframework.stereotype.Component;
   import util.IdWorker;
   
   /**
    * 存放所有用户微服务的bean
    */
   @Component
   public class UserApplicationConfig {
       
       @Bean
       public BCryptPasswordEncoder bcryptPasswordEncoder(){
           return new BCryptPasswordEncoder();
       }
   
       @Bean
       public IdWorker idWorker(){
           return new IdWorker(1, 8);
       }
   
   }
   ```

   这里我把`UserApplication`中的`IdWorker`的bean也放到这个类中。

### 管理员密码加密

1. 修改`AdminService#add`的逻辑，对原始密码进行加密存储

   ```java
   	@Autowired
   	private BCryptPasswordEncoder encoder;	
   	/**
   	 * 增加
   	 * @param admin
   	 */
   	public void add(Admin admin) {
   		String decodePassword = idWorker.nextId()+"";
   		//密码加密
   		admin.setPassword(encoder.encode(decodePassword));
   		adminDao.save(admin);
   	}
   ```

### 管理员登录验证

1. `AdminController`新增方法

   ```java
       /**
        * 用户登陆
        */
       @RequestMapping(value = "/login", method = RequestMethod.POST)
       public Result login(@RequestBody Map<String, String> loginMap) {
           Admin admin = adminService.findByLoginnameAndPassword(loginMap.get("loginname"), loginMap.get("password"));
           if (admin != null) {
               return new Result(true, StatusCode.OK, "登陆成功");
           }
           return new Result(false, StatusCode.LOGINERROR, "用户名或密码错误");
       }
   ```

2. `AdminService`新增方法

   ```java
   	/**
   	 * 根据登陆名和密码查询
   	 *
   	 * @param loginname
   	 * @param password
   	 * @return
   	 */
   	public Admin findByLoginnameAndPassword(String loginname, String password){
   		Admin admin = adminDao.findByLoginname(loginname);
   		if( admin!=null && encoder.matches(password,admin.getPassword())) {
   			return admin;
   		}
   		return null;
   	}
   ```

3. `AdminDao`新增方法

   ```java
   Admin findByLoginname(String loginname);
   ```

### 用户密码加密

1. 修改`UserService#add(User user, String code)`方法，对原始密码进行加密存储

   ```java
       /**
        * 增加
        *
        * @param user 用户
        * @param code 用户填写的验证码
        */
       public void add(User user, String code) {
           //判断验证码是否正确
           String syscode = (String) redisTemplate.opsForValue().get("smscode_" + user.getMobile());
           //提取系统正确的验证码
           if (syscode == null) {
               throw new RuntimeException("请点击获取短信验证码");
           }
           if (!syscode.equals(code)) {
               throw new RuntimeException("验证码输入不正确");
           }
           user.setId(idWorker.nextId() + "");
           user.setFollowcount(0);//关注数
           user.setFanscount(0);//粉丝数
           user.setOnline(0L);//在线时长
           user.setRegdate(new Date());//注册日期
           user.setUpdatedate(new Date());//更新日期
           user.setLastdate(new Date());//最后登陆日期
   
           //密码加密
           user.setPassword(encoder.encode(user.getPassword()));
   
           userDao.save(user);
       }
   ```

### 用户登录验证

1. `UserController`新增方法

   ```java
       /**
        * 用户登陆
        */
       @RequestMapping(value = "/login", method = RequestMethod.POST)
       public Result login(String mobile, String password) {
           User user = userService.findByMobileAndPassword(mobile, password);
           if (user != null) {
               return new Result(true, StatusCode.OK, "登陆成功");
           }
           return new Result(false, StatusCode.LOGINERROR, "用户名或密码错误");
       }
   ```

2. `UserService`新增方法

   ```java
       /**
        * 根据手机号和密码查询用户
        *
        * @param mobile
        * @param password
        * @return
        */
       public User findByMobileAndPassword(String mobile, String password) {
           User user = userDao.findByMobile(mobile);
           if (user != null && encoder.matches(password, user.getPassword())) {
               return user;
           }
           return null;
       }
   ```

3. `UserDao`新增方法

   ```java
   User findByMobile(String mobile);
   ```

# 鉴权微服务

## 鉴权微服务创建Module（省略）

## 准备工作

### 鉴权工具类

在`tensquare_common`中引入`JWT`依赖并编写工具类

1. 引入`JWT`依赖

   ```xml
   <dependency>
       <groupId>io.jsonwebtoken</groupId>
       <artifactId>jjwt</artifactId>
       <version>0.6.0</version>
   </dependency>
   ```

2. 编写工具类

   ```java
   package util;
   
   import io.jsonwebtoken.Claims;
   import io.jsonwebtoken.JwtBuilder;
   import io.jsonwebtoken.Jwts;
   import io.jsonwebtoken.SignatureAlgorithm;
   import lombok.Data;
   import org.springframework.boot.context.properties.ConfigurationProperties;
   
   import java.util.Date;
   
   @Data
   @ConfigurationProperties("jwt.config")
   public class JwtUtil {
   
       private String key ;
       private long ttl ;// token有效期
   
       /**
        * 生成JWT
        *
        * @param id
        * @param subject
        * @return
        */
       public String createJWT(String id, String subject, String roles) {
           long nowMillis = System.currentTimeMillis();
           Date now = new Date(nowMillis);
           JwtBuilder builder = Jwts.builder().setId(id)
                   .setSubject(subject)
                   .setIssuedAt(now)
                   .signWith(SignatureAlgorithm.HS256, key).claim("roles", roles);
           if (ttl > 0) {
               builder.setExpiration( new Date( nowMillis + ttl));
           }
           return builder.compact();
       }
   
       /**
        * 解析JWT
        * @param jwtStr
        * @return
        */
       public Claims parseJWT(String jwtStr){
           return Jwts.parser()
                   .setSigningKey(key)
                   .parseClaimsJws(jwtStr)
                   .getBody();
       }
   }
   ```

## 管理员后台登陆签发token

### 配置Jwt工具类Bean

在`UserApplicationConig`中配置`Bean`

```java
	@Bean
    public JwtUtil jwtUtil(){
        return new JwtUtil();
    }
```

### 配置JWT常量

在用户微服务中的`application.yml`中配置相关参数

```yaml
jwt:
  config:
    key: imxushuai
    ttl: 360000
```

### 修改AdminController#login方法

```java
    /**
     * 用户登陆
     */
    @RequestMapping(value = "/login", method = RequestMethod.POST)
    public Result login(@RequestBody Map<String, String> loginMap) {
        Admin admin = adminService.findByLoginnameAndPassword(loginMap.get("loginname"), loginMap.get("password"));
        if (admin != null) {
            //生成token
            String token = jwtUtil.createJWT(admin.getId(), admin.getLoginname(), "admin");
            Map<String, String> map = new HashMap<>();
            map.put("token", token);
            map.put("name", admin.getLoginname());//登陆名
            return new Result(true, StatusCode.OK, "登陆成功", map);
        }
        return new Result(false, StatusCode.LOGINERROR, "用户名或密码错误");
    }
```

## 统一鉴权拦截器

## 编写拦截器

```java
package com.tensquare.user.filter;

import io.jsonwebtoken.Claims;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import util.JwtUtil;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@Component
public class JwtFilter extends HandlerInterceptorAdapter {

    @Autowired
    private JwtUtil jwtUtil;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        final String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            final String token = authHeader.substring(7);
            Claims claims = jwtUtil.parseJWT(token);
            if (claims != null) {
                if("admin".equals(claims.get("roles"))){//如果是管理员
                    request.setAttribute("admin_claims", claims);
                }
                if("user".equals(claims.get("roles"))){//如果是用户
                    request.setAttribute("user_claims", claims);
                }
            }
        }
        return true;
    }
}

```

>  拦截器中只是对`token`进行解析，只要解析成功就放心，具体的操作权限交给具体的业务进行判断。
>
> 比如：删除用户
>
> ​	使用`admin`的token，在拦截器中会在`Request`中添加`key`为`admin_claims`的数据，在执行到具体的`controller`当中，只需要判断是否含有`admin_claims`的`key`即可，含有该`key`就执行逻辑，否则就抛出权限不足异常。

## 配置拦截器

```java
package com.tensquare.user.config;

import com.tensquare.user.filter.JwtFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

@Configuration
public class ApplicationConfig extends WebMvcConfigurationSupport {
    
    @Autowired
    private JwtFilter jwtFilter;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(jwtFilter).
                addPathPatterns("/**").
                excludePathPatterns("/**/login");
    }
}
```

## 用户登录生成token

修改`UserController#login`方法逻辑

```java
    @Autowired
    private JwtUtil jwtUtil;    
	/**
     * 用户登陆
     */
    @RequestMapping(value = "/login", method = RequestMethod.POST)
    public Result login(@RequestBody Map<String, String> loginMap) {
        User user = userService.findByMobileAndPassword(loginMap.get("mobile"), loginMap.get("password"));
        if (user != null) {
            String token = jwtUtil.createJWT(user.getId(),
                    user.getNickname(), "user");
            Map<String, String> map = new HashMap<>();
            map.put("token", token);
            map.put("name", user.getNickname());//昵称
            map.put("avatar", user.getAvatar());//头像
            return new Result(true, StatusCode.OK, "登陆成功", map);
        }
        return new Result(false, StatusCode.LOGINERROR, "用户名或密码错误");
    }
```

# 各微服务鉴权添加（省略）

